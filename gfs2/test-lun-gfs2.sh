#!/bin/bash

################################################################################
# Script: test-lun-gfs2.sh
# Descri√ß√£o: Script completo de teste e valida√ß√£o do cluster GFS2
#
# FUNCIONALIDADES:
# - Solicita nomes dos hosts do cluster interativamente
# - Verifica conectividade dos hosts antes de iniciar
# - Testa conectividade iSCSI entre n√≥s
# - Valida configura√ß√£o do cluster Pacemaker/Corosync
# - Verifica funcionamento do DLM (Distributed Lock Manager)
# - Testa sincroniza√ß√£o do filesystem GFS2
# - Valida multipath e redund√¢ncia
# - Executa testes de performance b√°sicos
# - Gera relat√≥rio completo de status
#
# PR√â-REQUISITOS:
# - Cluster GFS2 configurado com scripts anteriores
# - Conectividade de rede entre os n√≥s
# - GFS2 montado em /mnt/gfs2
#
# USO:
# sudo ./test-lun-gfs2.sh
#
# VERS√ÉO: 2.0 - Entrada interativa de hosts e verifica√ß√£o de conectividade
################################################################################

function log_info {
    echo "‚ÑπÔ∏è  $1"
}

function log_success {
    echo "‚úÖ $1"
}

function log_error {
    echo "‚ùå $1"
}

function log_warning {
    echo "‚ö†Ô∏è  $1"
}

function test_result {
    if [ $1 -eq 0 ]; then
        PASSED_TESTS=$((PASSED_TESTS + 1))
        log_success "$2"
    else
        FAILED_TESTS=$((FAILED_TESTS + 1))
        log_error "$2"
    fi
    TOTAL_TESTS=$((TOTAL_TESTS + 1))
}

function error_exit {
    echo "‚ùå Erro: $1"
    exit 1
}

function check_host_connectivity {
    local host="$1"
    local timeout="3"
    
    log_info "Verificando conectividade com $host..."
    
    # Teste de ping
    if ping -c 2 -W $timeout "$host" &>/dev/null; then
        log_success "$host est√° acess√≠vel via ping"
        return 0
    else
        log_error "$host n√£o est√° acess√≠vel via ping"
        return 1
    fi
}

function check_ssh_connectivity {
    local host="$1"
    
    log_info "Verificando conectividade SSH com $host..."
    
    # Teste de SSH (timeout de 5 segundos)
    if timeout 5 ssh -o ConnectTimeout=3 -o BatchMode=yes "$host" "echo 'SSH OK'" &>/dev/null; then
        log_success "$host est√° acess√≠vel via SSH"
        return 0
    else
        log_warning "$host n√£o est√° acess√≠vel via SSH (normal se n√£o configurado)"
        return 1
    fi
}

# === CONFIGURA√á√ÉO INICIAL DOS HOSTS ===
echo "======================================================================"
echo "üß™ TESTE COMPLETO DO CLUSTER GFS2"
echo "======================================================================"
echo "Data/Hora: $(date)"

echo ""
log_info "Configura√ß√£o dos n√≥s do cluster..."

# Detectar hostname atual
CURRENT_NODE=$(hostname)
echo "N√≥ atual detectado: $CURRENT_NODE"

# Solicitar informa√ß√µes dos hosts do cluster
echo ""
echo "üìã CONFIGURA√á√ÉO DOS N√ìS DO CLUSTER:"
echo "Por favor, informe os nomes dos hosts que comp√µem o cluster."

# Solicitar primeiro n√≥
read -p "Nome do primeiro n√≥ do cluster [$CURRENT_NODE]: " NODE1
NODE1=${NODE1:-$CURRENT_NODE}

# Solicitar segundo n√≥
while true; do
    read -p "Nome do segundo n√≥ do cluster: " NODE2
    
    if [ -z "$NODE2" ]; then
        log_error "O nome do segundo n√≥ n√£o pode estar vazio"
        continue
    fi
    
    if [ "$NODE2" = "$NODE1" ]; then
        log_error "O segundo n√≥ deve ter nome diferente do primeiro ($NODE1)"
        continue
    fi
    
    break
done

# Determinar qual √© o outro n√≥ em rela√ß√£o ao atual
if [ "$CURRENT_NODE" = "$NODE1" ]; then
    OTHER_NODE="$NODE2"
elif [ "$CURRENT_NODE" = "$NODE2" ]; then
    OTHER_NODE="$NODE1"
else
    log_warning "N√≥ atual ($CURRENT_NODE) n√£o corresponde aos n√≥s informados ($NODE1, $NODE2)"
    OTHER_NODE="$NODE1"  # Assumir primeiro n√≥ como padr√£o
fi

echo ""
echo "üìã CONFIGURA√á√ÉO CONFIRMADA:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "N√≥ 1:               $NODE1"
echo "N√≥ 2:               $NODE2"
echo "N√≥ atual:           $CURRENT_NODE"
echo "Outro n√≥:           $OTHER_NODE"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# === VERIFICA√á√ÉO DE CONECTIVIDADE PR√âVIA ===
echo ""
log_info "VERIFICA√á√ïES PRELIMINARES: Testando conectividade dos hosts..."

CONNECTIVITY_ISSUES=0

# Verificar conectividade com ambos os n√≥s
for node in "$NODE1" "$NODE2"; do
    if [ "$node" != "$CURRENT_NODE" ]; then
        if ! check_host_connectivity "$node"; then
            CONNECTIVITY_ISSUES=$((CONNECTIVITY_ISSUES + 1))
        fi
        
        # Teste opcional de SSH
        check_ssh_connectivity "$node"
    else
        log_success "$node √© o n√≥ atual (conectividade local OK)"
    fi
done

# Verificar se h√° problemas cr√≠ticos de conectividade
if [ $CONNECTIVITY_ISSUES -gt 0 ]; then
    echo ""
    log_error "Problemas de conectividade detectados com $CONNECTIVITY_ISSUES n√≥(s)"
    echo ""
    echo "‚ö†Ô∏è  OP√á√ïES:"
    echo "1. Continuar mesmo assim (testes de conectividade falhar√£o)"
    echo "2. Corrigir problemas de rede e executar novamente"
    echo "3. Cancelar execu√ß√£o"
    
    read -p "Escolha uma op√ß√£o [1/2/3]: " CONNECTIVITY_CHOICE
    
    case $CONNECTIVITY_CHOICE in
        1)
            log_warning "Continuando com problemas de conectividade..."
            ;;
        2|3)
            echo "Execu√ß√£o cancelada. Corrija os problemas de rede e tente novamente."
            echo ""
            echo "üí° DICAS PARA RESOLU√á√ÉO:"
            echo "- Verifique se os nomes dos hosts est√£o corretos"
            echo "- Confirme resolu√ß√£o DNS ou configure /etc/hosts"
            echo "- Teste conectividade: ping $OTHER_NODE"
            echo "- Verifique firewall e configura√ß√µes de rede"
            exit 1
            ;;
        *)
            log_warning "Op√ß√£o inv√°lida, continuando..."
            ;;
    esac
fi

# Confirma√ß√£o final antes de iniciar testes
echo ""
read -p "Iniciar testes do cluster GFS2? [S/n]: " START_TESTS
START_TESTS=$(echo "${START_TESTS:-s}" | tr '[:upper:]' '[:lower:]')

if [[ "$START_TESTS" != "s" && "$START_TESTS" != "y" ]]; then
    echo "Testes cancelados pelo usu√°rio."
    exit 0
fi

# === IN√çCIO DOS TESTES ===
echo ""
echo "======================================================================"
echo "üöÄ INICIANDO TESTES DO CLUSTER GFS2"
echo "======================================================================"

# Contadores de testes
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# === TESTE 1: Verificar Servi√ßos B√°sicos ===
echo ""
log_info "TESTE 1: Verificando servi√ßos essenciais..."

# Corosync
systemctl is-active --quiet corosync
test_result $? "Servi√ßo Corosync est√° ativo"

# Pacemaker
systemctl is-active --quiet pacemaker
test_result $? "Servi√ßo Pacemaker est√° ativo"

# DLM
pgrep -x dlm_controld >/dev/null
test_result $? "Daemon dlm_controld est√° rodando"

# LVM Lock Daemon
pgrep -x lvmlockd >/dev/null
test_result $? "Daemon lvmlockd est√° rodando"

# Multipath
systemctl is-active --quiet multipathd
test_result $? "Servi√ßo multipathd est√° ativo"

# === TESTE 2: Verificar Status do Cluster ===
echo ""
log_info "TESTE 2: Verificando status do cluster..."

# Verificar se cluster est√° online
pcs status &>/dev/null
test_result $? "Cluster est√° respondendo aos comandos pcs"

# Verificar n√∫mero de n√≥s online
NODES_ONLINE=$(pcs status 2>/dev/null | grep "Online:" | grep -o '\[.*\]' | tr -d '[]' | wc -w)
if [ "$NODES_ONLINE" -ge 2 ]; then
    test_result 0 "M√∫ltiplos n√≥s online no cluster ($NODES_ONLINE n√≥s)"
else
    test_result 1 "N√∫mero insuficiente de n√≥s online ($NODES_ONLINE n√≥s)"
fi

# Verificar se os n√≥s especificados est√£o no cluster
for node in "$NODE1" "$NODE2"; do
    pcs status 2>/dev/null | grep -q "$node"
    test_result $? "N√≥ $node est√° presente no cluster"
done

# Verificar se h√° quorum
pcs status 2>/dev/null | grep -q "partition with quorum"
test_result $? "Cluster possui quorum"

# === TESTE 3: Verificar Device Multipath ===
echo ""
log_info "TESTE 3: Verificando configura√ß√£o multipath..."

# Verificar se device multipath existe
[ -e /dev/mapper/fc-lun-cluster ]
test_result $? "Device multipath /dev/mapper/fc-lun-cluster existe"

# Verificar status do multipath
multipath -l fc-lun-cluster &>/dev/null
test_result $? "Device multipath est√° configurado corretamente"

# Verificar se device est√° acess√≠vel
dd if=/dev/mapper/fc-lun-cluster of=/dev/null bs=4096 count=1 &>/dev/null
test_result $? "Device multipath est√° acess√≠vel para leitura"

# === TESTE 4: Verificar DLM ===
echo ""
log_info "TESTE 4: Verificando Distributed Lock Manager..."

# Verificar status do DLM
dlm_tool status &>/dev/null
test_result $? "DLM est√° respondendo"

# Verificar lockspaces
LOCKSPACES=$(dlm_tool ls 2>/dev/null | wc -l)
if [ "$LOCKSPACES" -gt 0 ]; then
    test_result 0 "DLM possui lockspaces ativos ($LOCKSPACES lockspaces)"
else
    test_result 1 "DLM n√£o possui lockspaces ativos"
fi

# === TESTE 5: Verificar Montagem GFS2 ===
echo ""
log_info "TESTE 5: Verificando filesystem GFS2..."

# Verificar se GFS2 est√° montado
mount | grep -q "type gfs2"
test_result $? "Filesystem GFS2 est√° montado"

# Verificar ponto de montagem
[ -d /mnt/gfs2 ] && mount | grep -q "/mnt/gfs2"
test_result $? "GFS2 montado em /mnt/gfs2"

# Verificar se √© realmente GFS2
FSTYPE=$(df -T /mnt/gfs2 2>/dev/null | tail -1 | awk '{print $2}')
[ "$FSTYPE" = "gfs2" ]
test_result $? "Filesystem √© realmente GFS2"

# Verificar permiss√µes de escrita
touch /mnt/gfs2/.test-write-$CURRENT_NODE 2>/dev/null
test_result $? "Filesystem permite escrita"

# === TESTE 6: Teste de Sincroniza√ß√£o ===
echo ""
log_info "TESTE 6: Testando sincroniza√ß√£o entre n√≥s..."

# Criar arquivo de teste √∫nico
TEST_FILE="/mnt/gfs2/test-sync-$(date +%s)-$CURRENT_NODE.txt"
TEST_CONTENT="Teste de sincroniza√ß√£o do $CURRENT_NODE em $(date)"

echo "$TEST_CONTENT" > "$TEST_FILE" 2>/dev/null
test_result $? "Cria√ß√£o de arquivo de teste"

# Verificar se arquivo foi criado
[ -f "$TEST_FILE" ]
test_result $? "Arquivo de teste existe no filesystem"

# Verificar conte√∫do
CONTENT_CHECK=$(cat "$TEST_FILE" 2>/dev/null)
[ "$CONTENT_CHECK" = "$TEST_CONTENT" ]
test_result $? "Conte√∫do do arquivo est√° correto"

# === TESTE 7: Teste de Performance B√°sico ===
echo ""
log_info "TESTE 7: Teste b√°sico de performance..."

# Teste de escrita sequencial
WRITE_TEST_FILE="/mnt/gfs2/write-test-$CURRENT_NODE.dat"
dd if=/dev/zero of="$WRITE_TEST_FILE" bs=1M count=10 &>/dev/null
test_result $? "Teste de escrita sequencial (10MB)"

# Teste de leitura sequencial
dd if="$WRITE_TEST_FILE" of=/dev/null bs=1M &>/dev/null
test_result $? "Teste de leitura sequencial"

# Limpeza do arquivo de teste
rm -f "$WRITE_TEST_FILE" 2>/dev/null

# === TESTE 8: Verificar Conectividade com Outros N√≥s ===
echo ""
log_info "TESTE 8: Verificando conectividade entre n√≥s..."

# Teste de conectividade com outros n√≥s
for node in "$NODE1" "$NODE2"; do
    if [ "$node" != "$CURRENT_NODE" ]; then
        # Teste de ping
        ping -c 2 "$node" &>/dev/null
        test_result $? "Conectividade de rede com $node"
        
        # Verificar se n√≥ est√° no cluster
        pcs status 2>/dev/null | grep -q "$node"
        test_result $? "$node est√° presente no status do cluster"
    fi
done

# === TESTE 9: Verificar Configura√ß√£o de Fencing ===
echo ""
log_info "TESTE 9: Verificando configura√ß√£o de fencing..."

# Verificar se h√° recursos STONITH
STONITH_RESOURCES=$(pcs stonith show 2>/dev/null | wc -l)
if [ "$STONITH_RESOURCES" -gt 0 ]; then
    test_result 0 "Recursos STONITH configurados ($STONITH_RESOURCES recursos)"
else
    # Verificar se STONITH est√° desabilitado (aceit√°vel para lab)
    pcs property show stonith-enabled 2>/dev/null | grep -q "false"
    if [ $? -eq 0 ]; then
        log_warning "STONITH desabilitado (adequado para laborat√≥rio)"
        TOTAL_TESTS=$((TOTAL_TESTS + 1))
    else
        test_result 1 "STONITH n√£o configurado e n√£o desabilitado"
    fi
fi

# === TESTE 10: Verificar Logs de Erro ===
echo ""
log_info "TESTE 10: Verificando logs do sistema..."

# Verificar logs do Corosync
COROSYNC_ERRORS=$(journalctl -u corosync --since "5 minutes ago" | grep -i error | wc -l)
if [ "$COROSYNC_ERRORS" -eq 0 ]; then
    test_result 0 "Sem erros recentes no Corosync"
else
    test_result 1 "Encontrados $COROSYNC_ERRORS erros no Corosync"
fi

# Verificar logs do GFS2
GFS2_ERRORS=$(dmesg | grep -i gfs2 | grep -i error | wc -l)
if [ "$GFS2_ERRORS" -eq 0 ]; then
    test_result 0 "Sem erros do GFS2 no dmesg"
else
    test_result 1 "Encontrados $GFS2_ERRORS erros do GFS2"
fi

# === RELAT√ìRIO FINAL ===
echo ""
echo "======================================================================"
echo "üìä RELAT√ìRIO FINAL DOS TESTES"
echo "======================================================================"

echo ""
echo "üìã RESUMO DOS RESULTADOS:"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Total de testes:    $TOTAL_TESTS"
echo "Testes aprovados:   $PASSED_TESTS"
echo "Testes falharam:    $FAILED_TESTS"

if [ "$FAILED_TESTS" -eq 0 ]; then
    echo "Status geral:       ‚úÖ TODOS OS TESTES APROVADOS"
    OVERALL_STATUS="SUCESSO"
else
    PERCENTAGE=$((PASSED_TESTS * 100 / TOTAL_TESTS))
    echo "Taxa de sucesso:    $PERCENTAGE%"
    if [ "$PERCENTAGE" -ge 80 ]; then
        echo "Status geral:       ‚ö†Ô∏è  MAJORITARIAMENTE FUNCIONAL"
        OVERALL_STATUS="FUNCIONAL"
    else
        echo "Status geral:       ‚ùå PROBLEMAS CR√çTICOS DETECTADOS"
        OVERALL_STATUS="PROBLEMAS"
    fi
fi
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

echo ""
echo "üîç INFORMA√á√ïES DO SISTEMA:"
echo "N√≥ atual:           $CURRENT_NODE"
echo "N√≥s do cluster:     $NODE1, $NODE2"
echo "Cluster name:       $(pcs status cluster 2>/dev/null | grep -i "cluster name" | awk '{print $3}' || echo "N√£o detectado")"
echo "N√≥s online:         $NODES_ONLINE/$EXPECTED_NODES"
echo "GFS2 mountpoint:    /mnt/gfs2"
echo "Device multipath:   /dev/mapper/fc-lun-cluster"

echo ""
echo "üìÅ COMANDOS √öTEIS PARA DIAGN√ìSTICO:"
echo "pcs status                          # Status geral do cluster"
echo "mount | grep gfs2                   # Verificar montagens GFS2"
echo "multipath -ll                       # Status do multipath"
echo "dlm_tool status                     # Status do DLM"
echo "ls -la /mnt/gfs2/                   # Conte√∫do do filesystem compartilhado"

if [ "$FAILED_TESTS" -gt 0 ]; then
    echo ""
    echo "‚ö†Ô∏è  RECOMENDA√á√ïES PARA PROBLEMAS:"
    echo "1. Verifique logs: journalctl -xe"
    echo "2. Reinicie servi√ßos: systemctl restart corosync pacemaker"
    echo "3. Confirme conectividade de rede entre todos os n√≥s:"
    for node in "$NODE1" "$NODE2"; do
        if [ "$node" != "$CURRENT_NODE" ]; then
            echo "   ping $node"
        fi
    done
    echo "4. Confirme que todos os n√≥s executaram install-lun-prerequisites.sh"
fi

echo ""
echo "üéØ TESTE DE SINCRONIZA√á√ÉO MANUAL:"
echo "# No $CURRENT_NODE:"
echo "echo 'teste-manual-$(date)' | sudo tee /mnt/gfs2/teste-manual.txt"
echo ""
for node in "$NODE1" "$NODE2"; do
    if [ "$node" != "$CURRENT_NODE" ]; then
        echo "# No $node:"
        echo "cat /mnt/gfs2/teste-manual.txt"
    fi
done

echo ""
if [ "$OVERALL_STATUS" = "SUCESSO" ]; then
    log_success "Cluster GFS2 est√° totalmente funcional!"
elif [ "$OVERALL_STATUS" = "FUNCIONAL" ]; then
    log_warning "Cluster GFS2 est√° funcionando, mas com algumas quest√µes menores"
else
    log_error "Cluster GFS2 possui problemas que precisam ser resolvidos"
fi

echo ""
echo "======================================================================"

# Limpar arquivos tempor√°rios
rm -f /mnt/gfs2/.test-write-$CURRENT_NODE 2>/dev/null
rm -f "$TEST_FILE" 2>/dev/null

exit $FAILED_TESTS
